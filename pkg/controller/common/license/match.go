// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package license

import (
	"sort"
	"time"

	"github.com/elastic/cloud-on-k8s/pkg/controller/elasticsearch/client"
)

type licenseWithTimeLeft struct {
	license   client.License
	parentUID string
	remaining time.Duration
}

// BestMatch tries to find the best matching license given a list of enterprise licenses based on the
// desired license type and the remaining validity period of the license.
// Returns the license, parent license UID, a bool indicating a match was found and an optional error.
func BestMatch(
	licenses []EnterpriseLicense,
	filter func(EnterpriseLicense) (bool, error),
) (client.License, string, bool) {
	return bestMatchAt(time.Now(), licenses, filter)
}

func bestMatchAt(
	now time.Time,
	licenses []EnterpriseLicense,
	filter func(EnterpriseLicense) (bool, error),
) (client.License, string, bool) {
	var license client.License
	var parentMeta string
	if len(licenses) == 0 {
		// no license at all
		return license, parentMeta, false
	}
	valid := filterValid(now, licenses, filter)
	if len(valid) == 0 {
		log.Info("No matching license found", "num_licenses", len(licenses))
		return license, parentMeta, false
	}
	sort.Slice(valid, func(i, j int) bool {
		t1, t2 := ElasticsearchLicenseTypeOrder[ElasticsearchLicenseType(valid[i].license.Type)],
			ElasticsearchLicenseTypeOrder[ElasticsearchLicenseType(valid[j].license.Type)]
		if t1 != t2 { // sort by type
			return t1 < t2
		}
		// and by remaining time
		return valid[i].remaining < valid[j].remaining
	})
	best := valid[len(valid)-1]
	return best.license, best.parentUID, true
}

func filterValid(now time.Time, licenses []EnterpriseLicense, filter func(EnterpriseLicense) (bool, error)) []licenseWithTimeLeft {
	filtered := make([]licenseWithTimeLeft, 0)
	for _, el := range licenses {
		if el.IsValid(now) {
			ok, err := filter(el)
			if err != nil {
				log.Error(err, "while checking license validity")
				continue
			}
			if !ok {
				continue
			}

			// Shortcut if it's a trial license
			if el.IsTrial() {
				filtered = append(filtered, licenseWithTimeLeft{
					// For a trial, only the type is used, the license will be generated by ES
					license: client.License{
						Type: string(ElasticsearchLicenseTypeTrial),
					},
					parentUID: el.License.UID,
					remaining: el.ExpiryTime().Sub(now),
				})
				continue
			}

			for _, l := range el.License.ClusterLicenses {
				if l.License.IsValid(now) {
					filtered = append(filtered, licenseWithTimeLeft{
						license:   l.License,
						parentUID: el.License.UID,
						remaining: l.License.ExpiryTime().Sub(now),
					})
				}
			}
		}
	}
	return filtered
}

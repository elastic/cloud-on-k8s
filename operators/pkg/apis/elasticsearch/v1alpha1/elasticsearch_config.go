// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package v1alpha1

import (
	"encoding/json"

	"github.com/elastic/go-ucfg"
)

const (
	NodeData   = "node.data"
	NodeIngest = "node.ingest"
	NodeMaster = "node.master"
	NodeML     = "node.ml"
)

type Config struct {
	Data map[string]interface{}
}

func NewConfig(cfg map[string]interface{}) Config {
	return Config{Data: cfg}
}

func (c *Config) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.Data)
}

func (c *Config) UnmarshalJSON(data []byte) error {
	var out map[string]interface{}
	err := json.Unmarshal(data, &out)
	if err != nil {
		return err
	}
	c.Data = out
	return nil
}

func (c Config) is(key string) bool {
	v, ok := c.Data[key]
	if !ok {
		// all roles are on by default
		return true
	}
	b, ok := v.(bool)
	if !ok {
		return false
	}
	return b
}

func (c Config) IsMaster() bool {
	return c.is(NodeMaster)
}

func (c Config) IsData() bool {
	return c.is(NodeData)
}

func (c Config) IsIngest() bool {
	return c.is(NodeIngest)
}

func (c Config) IsML() bool {
	return c.is(NodeML)
}

func (c Config) EqualRoles(c2 Config) bool {
	return c.IsMaster() == c2.IsMaster() &&
		c.IsData() == c2.IsData() &&
		c.IsIngest() == c2.IsIngest() &&
		c.IsML() == c2.IsML()
}

// DeepCopyInto is an ~autogenerated~ deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (c *Config) DeepCopyInto(out *Config) {
	bytes, err := json.Marshal(c.Data)
	if err != nil {
		panic(err)
	}
	var copy map[string]interface{}
	err = json.Unmarshal(bytes, &copy)
	if err != nil {
		panic(err)
	}
	out.Data = copy
	return
}

func (c Config) Canonicalize() (*ucfg.Config, error) {
	return ucfg.NewFrom(c.Data, ucfg.PathSep("."))
}

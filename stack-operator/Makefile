SHELL := /bin/bash
INSTALL_HELP = "please refer to the README.md for how to install it."
GO := $(shell command -v go)
GOIMPORTS := $(shell command -v goimports)
MINIKUBE := $(shell command -v minikube)
KUBECTL := $(shell command -v kubectl)
KUBEBUILDER := $(shell command -v kubebuilder)
KUSTOMIZE := $(shell command -v kustomize)
SHA1SUM := $(shell command -v sha1sum)
DEP := $(shell command -v dep)
GCLOUD := $(shell command -v gcloud)
GOLANGCI_LINTER := $(shell command -v golangci-lint)

KUBECTL_CONFIG ?= $(shell cat $(CONFIG_FILE) 2> /dev/null)
CONFIG_FILE ?= .devenv
MINIKUBE_KUBERNETES_VERSION ?= v1.12.0
MINIKUBE_MEMORY ?= 8192
MINIKUBE_CPUS ?= 4

GCLOUD_PROJECT ?= elastic-cloud-dev
GCLOUD_CLUSTER_NAME ?= $(subst _,,$(USER))-dev-cluster

GKE_CLUSTER_REGION ?= europe-west3
GKE_ADMIN_USERNAME ?= admin
GKE_CLUSTER_VERSION = $(shell gcloud container get-server-config --project=$(GCLOUD_PROJECT) --region $(GKE_CLUSTER_REGION) --format='value(validMasterVersions[0])' 2>/dev/null)
GKE_MACHINE_TYPE ?= n1-highmem-4
GKE_LOCAL_SSD_COUNT ?= 1
GKE_NODE_COUNT_PER_ZONE ?= 1
GKE_KUBECTL_CONFIG = gke_$(GCLOUD_PROJECT)_$(GKE_CLUSTER_REGION)_$(GCLOUD_CLUSTER_NAME)

GCR_REGISTRY ?= eu.gcr.io
LOCAL_REGISTRY ?= localhost:5000
# Image URL to use all building/pushing image targets
IMG_TAG ?= $(shell find pkg -type f -print0 | xargs -0 sha1sum | sha1sum | awk '{print $$1}')
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	IMG ?= $(GCR_REGISTRY)/$(GCLOUD_PROJECT)/$(subst _,,$(USER))
else
	IMG ?= $(LOCAL_REGISTRY)/$(GCLOUD_PROJECT)/$(subst _,,$(USER))
	IMG_TAG = latest
endif

E2E_IMG ?= $(IMG)-e2e-tests

OPERATOR_NAMESPACE ?= default

### Start of Autogenerated ###

all: unit integration stack-operator

# Run tests
unit:
	go test ./pkg/... ./cmd/... -coverprofile cover.out

integration: generate fmt vet manifests
	go test -tags=integration ./pkg/... ./cmd/... -coverprofile cover.out

# Build stack-operator binary
stack-operator: generate fmt vet
	go build -o bin/stack-operator github.com/elastic/stack-operators/stack-operator/cmd

# Build keystore updater
keystore-updater: generate fmt vet
	go build -o bin/keystore-updater github.com/elastic/stack-operators/stack-operator/cmd/keystore-updater

# CI job
.PHONY: ci
ci: check-fmt dep-vendor-only stack-operator integration keystore-updater

# Run against the configured Kubernetes cluster in ~/.kube/config
OPERATOR_IMAGE ?= $(IMG):$(IMG_TAG)
run: generate fmt vet
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	# Deploy on gke
	@ gcloud auth configure-docker
	@ $(MAKE) docker-build docker-push deploy
	@ echo "-> type \"make logs\" to tail the controller's logs."
else
	@ echo "-> Checking existence of the operator image in minikube..."
	@ eval $$(minikube docker-env) ; docker pull $(OPERATOR_IMAGE) &> /dev/null
	# Run the operator locally with port-forwarding enabled, so that
	# it can reach services running in the cluster through k8s port-forward feature
	AUTO_PORT_FORWARD=true OPERATOR_IMAGE=$(OPERATOR_IMAGE) \
		go run ./cmd/main.go manager --development $(MANAGER_ARGS) --namespace $(OPERATOR_NAMESPACE)
endif

.PHONY: logs
logs:
	@ kubectl --namespace=$(OPERATOR_NAMESPACE) logs -f statefulset.apps/elastic-namespace-operator

# Install CRDs into a cluster
install: manifests
	kubectl --cluster=$(KUBECTL_CONFIG) apply -f config/crds

# Deploy controller in the configured Kubernetes cluster in ~/.kube/config
deploy: manifests
	kubectl --cluster=$(KUBECTL_CONFIG) apply -f config/crds
	kustomize build config/default | kubectl --cluster=$(KUBECTL_CONFIG) apply --namespace $(OPERATOR_NAMESPACE) -f -

# Generate manifests e.g. CRD, RBAC etc.
manifests:
	go run vendor/sigs.k8s.io/controller-tools/cmd/controller-gen/main.go all

# Run go fmt against code
fmt:
	goimports -w pkg cmd

check-fmt:
ifneq ($(shell goimports -l pkg cmd),)
	$(error Invalid go formatting. Please run `make fmt`)
endif

# Run go vet against code
vet:
	go vet ./pkg/... ./cmd/...

# Generate code
generate:
	go generate ./pkg/... ./cmd/...

# Build the docker image
docker-build: unit
	docker build . -t $(IMG):$(IMG_TAG)
	@ echo "-> Updating kustomize image patch file for manager resource"
	@ cp config/default/manager_image_patch.orig.yaml config/default/manager_image_patch.yaml
	@ $(eval EXTRASEDFLAG := "''")
ifeq ($(shell uname -s),Linux)
	@ $(eval EXTRASEDFLAG := "-e")
endif
	sed -i ${EXTRASEDFLAG} 's@image: .*@image: '"$(IMG):$(IMG_TAG)"'@' config/default/manager_image_patch.yaml
	sed -i ${EXTRASEDFLAG} 's@value: .*@value: '"$(IMG):$(IMG_TAG)"'@' config/default/manager_image_patch.yaml

# Push the docker image
docker-push:
	docker push $(IMG):$(IMG_TAG)

###Â End of Autogenerated ###

.PHONY: requisites
requisites:
ifndef GO
	@ echo "-> go binary missing, $(INSTALL_HELP)"
	@ exit 1
endif
ifndef DEP
	@ echo "-> dep binary missing, $(INSTALL_HELP)"
	@ exit 1
endif
ifndef GOIMPORTS
	@ echo "-> goimports binary missing, $(INSTALL_HELP)"
	@ exit 1
endif
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
ifndef GCLOUD
	@ echo "-> gcloud binary missing, $(INSTALL_HELP)"
	@ exit 6
endif
else
ifndef MINIKUBE
	@ echo "-> minikube binary missing, $(INSTALL_HELP)"
	@ exit 2
endif
endif
ifndef KUBECTL
	@ echo "-> kubectl binary missing, $(INSTALL_HELP)"
	@ exit 3
endif
ifndef KUBEBUILDER
	@ echo "-> kubebuilder binary missing, $(INSTALL_HELP)"
	@ exit 4
endif
ifndef KUSTOMIZE
	@ echo "-> kustomize binary missing, $(INSTALL_HELP)"
	@ exit 7
endif
ifndef SHA1SUM
	@ echo "-> sha1sum binary missing, $(INSTALL_HELP)"
	@ exit 8
endif

# -- dev

.PHONY: dev
dev: dev-cluster dep-vendor-only unit stack-operator install samples
	@ echo "-> Development environment started"
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	@ echo "-> Run \"make run\" to build, push and deploy the controller in a docker image."
else
	@ echo "-> Run \"make run\" to start the manager process locally"
endif

.PHONY: dev-cluster
dev-cluster:
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	@ $(MAKE) gke
else
	# A registry is deployed in minikube and the latest operator image is pushed in
	@ $(MAKE) minikube registry lazy-push-latest-operator-image-in-local-registry
endif

.PHONY: delete-dev
delete-dev: purge-env
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	@ echo "-> Deleting GKE cluster..."
	@ gcloud beta --project $(GCLOUD_PROJECT) container clusters delete $(GCLOUD_CLUSTER_NAME) --region $(GKE_CLUSTER_REGION)
else
	@ echo "-> Deleting minikube cluster..."
	@ minikube stop && minikube delete
endif

.PHONY: gke
gke:
	@ echo "-> Checking GKE status..."
	@./hack/gcp-k8s-cluster.sh $(GCLOUD_PROJECT) $(GCLOUD_CLUSTER_NAME) $(GKE_CLUSTER_REGION) $(GKE_ADMIN_USERNAME) \
	$(GKE_CLUSTER_VERSION) $(GKE_MACHINE_TYPE) $(GKE_LOCAL_SSD_COUNT) $(GKE_NODE_COUNT_PER_ZONE)
	@ echo "$(GKE_KUBECTL_CONFIG)" > $(CONFIG_FILE)
	@ gcloud beta --project $(GCLOUD_PROJECT) container clusters get-credentials $(GCLOUD_CLUSTER_NAME) --region $(GKE_CLUSTER_REGION)

# minikube ensures that there's a local minikube environment running
.PHONY: minikube
minikube: requisites
ifneq ($(shell minikube status --format '{{.ApiServer}}'),Running)
	@ echo "-> Starting minikube..."
	@ minikube start --kubernetes-version $(MINIKUBE_KUBERNETES_VERSION) --memory ${MINIKUBE_MEMORY} --cpus ${MINIKUBE_CPUS}
else
	@ echo "-> minikube already started, skipping..."
endif
	@ echo "minikube" > $(CONFIG_FILE)

registry:
	@ echo "-> Deploying registry..."
	@ hack/registry.sh create

lazy-push-latest-operator-image-in-local-registry:
	@ hack/registry.sh port-forward start
	@ docker pull $(IMG):$(IMG_TAG) || $(MAKE) docker-build docker-push
	@ hack/registry.sh port-forward stop

force-push-latest-operator-image-in-local-registry:
	@ hack/registry.sh port-forward start
	@ $(MAKE) docker-build docker-push
	@ hack/registry.sh port-forward stop

# samples pushes the samples to the configured Kubernetes cluster.
.PHONY: samples
samples: requisites generate
	@ echo "-> Pushing samples to Kubernetes cluster..."
	@ kubectl --cluster=$(KUBECTL_CONFIG) apply -f config/samples/deployments_v1alpha1_stack.yaml

.PHONY: dep
dep:
	dep ensure -v

dep-vendor-only:
	# don't attempt to upgrade Gopkg.lock
	dep ensure --vendor-only -v

.PHONY: set-dev-gke
set-dev-gke:
ifdef MINIKUBE
ifeq ($(shell minikube status --format '{{.Host}}'),Running)
	minikube stop
endif
endif
	@ echo $(GKE_KUBECTL_CONFIG) > $(CONFIG_FILE)

.PHONY: set-dev-minikube
set-dev-minikube:
	@ echo "minikube" > $(CONFIG_FILE)

.PHONY: purge-env
purge-env:
	@ echo "-> Purging cluster $(KUBECTL_CONFIG)..."
	@ echo "-> Purging $(OPERATOR_NAMESPACE) namespace..."
	@ kubectl --cluster=$(KUBECTL_CONFIG) --namespace=$(OPERATOR_NAMESPACE) delete statefulsets --all
	@ kubectl --cluster=$(KUBECTL_CONFIG) --namespace=$(OPERATOR_NAMESPACE) delete po --all
	@ kubectl --cluster=$(KUBECTL_CONFIG) --namespace=$(OPERATOR_NAMESPACE) delete svc --all
	@ echo "-> Purging default namespace..."
	@ kubectl --cluster=$(KUBECTL_CONFIG) delete deployments --all
	@ kubectl --cluster=$(KUBECTL_CONFIG) delete svc --all
	@ kubectl --cluster=$(KUBECTL_CONFIG) delete rc --all
	@ kubectl --cluster=$(KUBECTL_CONFIG) delete po --all

.PHONY: purge-gcr-images
purge-gcr-images:
	@ for i in $(gcloud container images list-tags $(IMG) | tail +3 | awk '{print $$2}'); \
		do gcloud container images untag $(IMG):$$i; \
	done

.PHONY: show-credentials
show-credentials:
	@ echo "elastic:$$(kubectl get secret stack-sample-elastic-user -o json | jq -r '.data.elastic' | base64 -D)"

.PHONY: lint
lint:
ifndef GOLANGCI_LINTER
	@ echo "-> linter (golangci-lint) binary missing, install via \"https://github.com/golangci/golangci-lint#install\""
	@ exit 5
endif
	@ $(GOLANGCI_LINTER) run $(LINTER_ARGS) ./pkg/... ./cmd/... ./test/...

# -- e2e tests

TESTS_MATCH ?= ""
# run e2e tests
# can be overriden with the name of the test to run, eg.:
# make e2e TESTS_MATCH=TestMutationMoreNodes
e2e: docker-e2e
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	# always pull latest img on gke
	./hack/run_e2e.sh "$(E2E_IMG):$(IMG_TAG)" Always "$(TESTS_MATCH)"
else
	# never pull on minikube (no registry)
	./hack/run_e2e.sh "$(E2E_IMG):$(IMG_TAG)" Never "$(TESTS_MATCH)"
endif

# run e2e tests locally (not as a k8s job), with a custom http dialer
# that can reach ES services running in the k8s cluster through port-forwarding
e2e-local:
	go test -v -failfast -timeout 1h -tags=e2e ./test/e2e -run "$(TESTS_MATCH)"  --auto-port-forward

# Build and (maybe) push e2e tests Docker image
docker-e2e:
ifeq ($(KUBECTL_CONFIG),$(GKE_KUBECTL_CONFIG))
	# build locally, then push to gke registry
	docker build -t $(E2E_IMG):$(IMG_TAG) -f test/e2e/Dockerfile .
	docker push $(E2E_IMG):$(IMG_TAG)
else
	# build with Minikube's Docker, don't push
	eval $$(minikube docker-env) ;\
	docker build -t $(E2E_IMG):$(IMG_TAG) -f test/e2e/Dockerfile .
endif

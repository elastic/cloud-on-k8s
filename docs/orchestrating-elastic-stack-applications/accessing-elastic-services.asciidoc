:page_id: accessing-elastic-services
ifdef::env-github[]
****
link:https://www.elastic.co/guide/en/cloud-on-k8s/master/k8s-{page_id}.html[View this document on the Elastic website]
****
endif::[]
[id="{p}-{page_id}"]
= Access Elastic Stack services

To access the Elastic Stack services, you need to:

- Retrieve the `elastic` user password for basic authentication.
- Specify the IP of the service, if you want to access the service from outside the Kubernetes cluster.
- Decide if you want to use the self-signed certificate generated by ECK, or configure your own certificate.

The following sections will guide you through this process:

- <<{p}-security>>
- <<{p}-services>>
- <<{p}-tls-certificates>>
- <<{p}-request-elasticsearch-endpoint>>

[id="{p}-security"]
== Security

All Elastic Stack resources deployed by the ECK operator are secured by default. The operator sets up basic authentication and TLS to encrypt network traffic to, from, and within your Elasticsearch cluster.

[id="{p}-authentication"]
=== Authentication

To access Elastic resources, the operator manages a default user named `elastic` with the `superuser` role. Its password is stored in a `Secret` named `<name>-elastic-user`.

[source,sh]
----
> kubectl get secret hulk-es-elastic-user -o go-template='{{.data.elastic | base64decode }}'
42xyz42citsale42xyz42
----

NOTE: Beware of copying this Secret as-is into a different namespace. Check <<{p}-common-problems-owner-refs, Common Problems: Owner References>> for more information.

[id="{p}-services"]
== Services

You can access Elastic resources by using native Kubernetes services that are not reachable from the public Internet by default.

[id="{p}-kubernetes-service"]
=== Manage Kubernetes services

For each resource, the operator manages a Kubernetes service named `<name>-[es|kb|apm|ent|agent]-http`, which is of type `ClusterIP` by default. `ClusterIP` exposes the service on a cluster-internal IP and makes the service only reachable from the cluster.

[source,sh]
----
> kubectl get svc

NAME                TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE
hulk-apm-http       ClusterIP      10.19.212.105   <none>           8200/TCP   1m
hulk-es-http        ClusterIP      10.19.252.160   <none>           9200/TCP   1m
hulk-kb-http        ClusterIP      10.19.247.151   <none>           5601/TCP   1m
----

[id="{p}-allow-public-access"]
=== Allow public access

You can expose services in link:https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types[different ways] by specifying an `http.service.spec.type` in the `spec` of the resource manifest.
On cloud providers which support external load balancers, you can set the `type` field to `LoadBalancer` to provision a load balancer for the `Service`, and populate the column `EXTERNAL-IP` after a short delay. Depending on the cloud provider, it may incur costs.

By default, the Elasticsearch service created by ECK is configured to route traffic to all Elasticsearch nodes in the cluster. Depending on your cluster configuration, you may want more control over the set of nodes that handle different types of traffic (query, ingest, and so on). Check <<{p}-traffic-splitting>> for more information.

CAUTION: When you change the `clusterIP` setting of the service, ECK will delete and re-create the service as `clusterIP` is an immutable field. Depending on your client implementation, this might result in a short disruption until the service DNS entries refresh to point to the new endpoints.

[source,yaml,subs="attributes"]
----
apiVersion: <kind>.k8s.elastic.co/{eck_crd_version}
kind: <Kind>
metadata:
  name: hulk
spec:
  version: {version}
  http:
    service:
      spec:
        type: LoadBalancer
----

[source,sh]
----
> kubectl get svc

NAME                TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE
hulk-apm-http       LoadBalancer   10.19.212.105   35.176.227.106   8200:31000/TCP   1m
hulk-es-http        LoadBalancer   10.19.252.160   35.198.131.115   9200:31320/TCP   1m
hulk-kb-http        LoadBalancer   10.19.247.151   35.242.197.228   5601:31380/TCP   1m
----


[id="{p}-tls-certificates"]
== TLS certificates

This section only covers TLS certificates for the HTTP layer. TLS certificates for the transport layer that are used for internal communications between Elasticsearch nodes are managed by ECK and cannot be changed. You can however set your own certificate authority for the <<{p}-transport-ca,transport layer>>.

[id="{p}-default-self-signed-certificate"]
=== Default self-signed certificate

By default, the operator manages a self-signed certificate with a custom CA for each resource.
The CA, the certificate and the private key are each stored in a separate `Secret`.

[source,sh]
----
> kubectl get secret | grep es-http
hulk-es-http-ca-internal         Opaque                                2      28m
hulk-es-http-certs-internal      Opaque                                2      28m
hulk-es-http-certs-public        Opaque                                1      28m
----

The public certificate is stored in a secret named `<name>-[es|kb|apm|ent|agent]-http-certs-public`.

[source,sh]
----
> kubectl get secret hulk-es-http-certs-public -o go-template='{{index .data "tls.crt" | base64decode }}'
-----BEGIN CERTIFICATE-----
MIIDQDCCAiigAwIBAgIQHC4O/RWX15a3/P3upsm3djANBgkqhkiG9w0BAQsFADA6
...
QLYL4zLEby3vRxq65+xofVBJAaM=
-----END CERTIFICATE-----
----

[id="{p}-static-ip-custom-domain"]
==== Reserve static IP and custom domain

To use a custom domain name with the self-signed certificate, you can reserve a static IP and/or use an Ingress instead of a `LoadBalancer` `Service`. Whatever you use, your DNS must be added to the certificate SAN in the `spec.http.tls.selfSignedCertificate.subjectAltNames` section of your Elastic resource manifest.

[source,yaml]
----
spec:
  http:
    service:
      spec:
        type: LoadBalancer
    tls:
      selfSignedCertificate:
        subjectAltNames:
        - ip: 160.46.176.15
        - dns: hulk.example.com
----

[id="{p}-setting-up-your-own-certificate"]
=== Setup your own certificate

You can bring your own certificate to configure TLS to ensure that communication between HTTP clients and the Elastic Stack application is encrypted.

Create a Kubernetes secret with:

- `ca.crt`: CA certificate (optional if `tls.crt` was issued by a well-known CA).
- `tls.crt`: The certificate.
- `tls.key`: The private key to the first certificate in the certificate chain.

[source,sh]
----
kubectl create secret generic my-cert --from-file=ca.crt --from-file=tls.crt --from-file=tls.key
----

Alternatively you can also bring your own CA certificate including a private key and let ECK issue certificates with it. Any certificate SANs you have configured as decribed in <<{p}-static-ip-custom-domain>> will also be respected when issuing certificates with this CA certificate.

Create a Kubernetes secret with:

- `ca.crt`: CA certificate.
- `ca.key`: The private key to the CA certificate.

[source,sh]
----
kubectl create secret generic my-cert --from-file=ca.crt --from-file=ca.key
----

In both cases, you have to reference the secret name in the `http.tls.certificate` section of the resource manifest.

[source,yaml]
----
spec:
  http:
    tls:
      certificate:
        secretName: my-cert
----

[id="{p}-disable-tls"]
=== Disable TLS

You can explicitly disable TLS for Kibana, APM Server, Enterprise Search and the HTTP layer of Elasticsearch.

[source,yaml]
----
spec:
  http:
    tls:
      selfSignedCertificate:
        disabled: true
----

[id="{p}-request-elasticsearch-endpoint"]
== Access the Elasticsearch endpoint

You can access the Elasticsearch endpoint within or outside the Kubernetes cluster.

*Within the Kubernetes cluster*

. Retrieve the CA certificate.
. Retrieve the password of the `elastic` user.

[source,sh]
----
NAME=hulk

kubectl get secret "$NAME-es-http-certs-public" -o go-template='{{index .data "tls.crt" | base64decode }}' > tls.crt
PW=$(kubectl get secret "$NAME-es-elastic-user" -o go-template='{{.data.elastic | base64decode }}')

curl --cacert tls.crt -u elastic:$PW https://$NAME-es-http:9200/
----

*Outside the Kubernetes cluster*

. Retrieve the CA certificate.
. Retrieve the password of the `elastic` user.
. Retrieve the IP of the `LoadBalancer` `Service`.

[source,sh]
----
NAME=hulk

kubectl get secret "$NAME-es-http-certs-public" -o go-template='{{index .data "tls.crt" | base64decode }}' > tls.crt
IP=$(kubectl get svc "$NAME-es-http" -o jsonpath='{.status.loadBalancer.ingress[].ip}')
PW=$(kubectl get secret "$NAME-es-elastic-user" -o go-template='{{.data.elastic | base64decode }}')

curl --cacert tls.crt -u elastic:$PW https://$IP:9200/
----

# Go-based Elasticsearch Keystore for Hot-Reloadable Secure Settings

* Status: proposed
* Deciders: ECK & Elasticsearch teams
* Date: 2026-01-08

Technical Story: Enable hot-reloading of Elasticsearch secure settings without pod restarts

## Context and Problem Statement

Updating Elasticsearch secure settings (stored in the keystore) previously required pod restarts because the keystore was generated by an init container at pod startup. This caused service disruption for what should be a non-disruptive configuration change.

Elasticsearch 9.3 introduces an enhanced `_nodes/reload_secure_settings` API that returns keystore digests, enabling the operator to detect when all nodes have successfully reloaded an updated keystore. How should ECK create and manage keystore files to enable this hot-reload capability?

## Decision Drivers

* **Security**: Minimize exposure of sensitive settings data
* **Simplicity**: Reduce architectural complexity and moving parts
* **Reliability**: Ensure consistent behavior across environments (OpenShift, restricted clusters, etc.)
* **Maintainability**: Balance implementation effort against long-term maintenance burden
* **Performance**: Minimize reconciliation latency and resource usage

## Considered Options

1. **Go Reimplementation**: Implement the keystore file format directly in Go within the operator
2. **Job-Based Approach**: Run Kubernetes Jobs using the ES container image to create keystore files via the `elasticsearch-keystore` CLI
3. **Jobs in ES Namespace**: Run Jobs in the Elasticsearch namespace instead of the operator namespace

## Decision Outcome

Chosen option: **Go Reimplementation**, because it provides the best balance of security, simplicity, and reliability while having an acceptable maintenance burden.

### Positive Consequences

* Simpler architecture with no Jobs, staging Secrets, or cross-namespace operations
* Better security postureâ€”secrets never leave the Elasticsearch namespace
* No additional RBAC permissions required
* Works in restricted environments (no need to schedule additional workloads)
* Faster reconciliation (no waiting for Job completion)
* Standard Kubernetes garbage collection applies (Secret owned by ES resource)

### Negative Consequences

* ECK team must track keystore format changes and update the implementation
* Initial implementation effort to reverse-engineer the format from Java source
* Potential compatibility gaps if ES changes the format unexpectedly

## Pros and Cons of the Options

### Option 1: Go Reimplementation

Generate keystore files directly in Go within the operator.

* Good, because it's a simpler architecture with no external dependencies
* Good, because secrets never leave the Elasticsearch namespace
* Good, because no additional RBAC permissions are required
* Good, because it works in restricted environments
* Good, because reconciliation is faster (no Job scheduling)
* Good, because standard Kubernetes GC applies
* Bad, because ECK must maintain the keystore format implementation
* Bad, because format changes require ECK updates

### Option 2: Job-Based Approach

Uses Kubernetes Jobs running the ES container image to invoke `elasticsearch-keystore create`.

* Good, because it uses official ES tooling, ensuring format correctness
* Good, because new ES versions with format changes work automatically
* Bad, because it requires complex architecture (Jobs, staging Secrets, cross-namespace copying)
* Bad, because secure settings are temporarily copied to the operator namespace
* Bad, because image pull secrets may differ per namespace, causing Job failures
* Bad, because OpenShift UID range restrictions can complicate Job execution across namespaces when using the Elasticsearch pod template as the job template
* Bad, because Jobs and staging Secrets require explicit garbage collection when ES resources are deleted
* Bad, because it requires `--operator-image` flag configuration to make the operator aware of its own image for job creation

### Option 3: Jobs in ES Namespace

Run Jobs in the Elasticsearch namespace using dynamically created ServiceAccounts.

* Good, because it solves cross-namespace security concerns
* Good, because it uses official ES tooling
* Bad, because it still requires Job management complexity
* Bad, because it needs additional RBAC for ServiceAccount/RoleBinding creation
* Bad, because while ValidatingAdmissionPolicy (K8s 1.30+) allows to restrict operator permissions, there is no good mechanism to ship these in all distribution channels e.g. OLM
* Bad, because in order to leverage ValidatingAdmissinoPolicy we are forced to share a secret between all ES clusters in a namespace

## Format Stability Analysis

The Elasticsearch keystore format is well-documented in [KeyStoreWrapper.java](https://github.com/elastic/elasticsearch/blob/main/server/src/main/java/org/elasticsearch/common/settings/KeyStoreWrapper.java):

| Version | Changes | ES Version |
|---------|---------|------------|
| v1 | Initial version | 5.3 |
| v2 | File setting | 5.4 |
| v3 | FIPS compliant algorithms | 6.3 |
| v4 | Remove string/file distinction | 6.8/7.1 |
| v5 | Lucene directory API changed to LE | 8.0 |
| v6 | Increase KDF iteration count | 8.14 |
| v7 | Increase cipher key length to 256 bits | 9.0 |

**Key observations**:
- Format changes are infrequent (~2 versions in 3 years for v6/v7)
- Changes are well-documented and relatively simple
- Elasticsearch has a conservative deprecation policy (5+ years before removing old format support)
- The hot-reload feature requires ES 9.3+, which uses v7 only

## Implementation Details

The Go implementation consists of:

1. **Lucene Codec Layer** (`codec.go`): File structure with headers, footers, and CRC32 checksums
2. **Cryptography Layer** (`crypto.go`): PBKDF2-HMAC-SHA512 key derivation, AES-GCM encryption
3. **Entry Serialization** (`entries.go`): Java DataOutputStream-compatible format
4. **Version Configuration** (`version.go`): Format version parameters (simplified to v7 only)
5. **Reconciliation** (`reconciler.go`): Kubernetes Secret management with change detection

**Optimizations**:
- Settings hash annotation to skip regeneration when settings unchanged
- Status-based digest caching to skip redundant reload API calls
- Symlink-based Secret mounting for automatic updates without pod restarts

## Links

* [PR #8958](https://github.com/elastic/cloud-on-k8s/pull/8958): Original Job-based implementation and discussion
* [KeyStoreWrapper.java](https://github.com/elastic/elasticsearch/blob/main/server/src/main/java/org/elasticsearch/common/settings/KeyStoreWrapper.java): Elasticsearch keystore implementation
* [Elasticsearch reload_secure_settings API](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-reload-secure-settings.html): API documentation


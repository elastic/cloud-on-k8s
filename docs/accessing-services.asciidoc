[id="{p}-accessing-elastic-services"]
== How to access Elastic Stack services

To access the Elastic Stack services, you will need to retrieve:

- the `elastic` user password for basic authentication
- the IP of the service, if you want to access the service from outside the Kubernetes cluster

And choose between:

- using the self-signed certificate with the custom CA (Certificate Authority) generated by ECK
- configuring your own certificate

[float]
[id="{p}-security"]
=== Security

All Elastic Stack resources deployed by the ECK Operator are secured by default. The operator sets up basic authentication and TLS to encrypt network traffic to, from, and within your Elasticsearch cluster.

[float]
[id="{p}-authentication"]
==== Authentication

To access Elasticsearch and Kibana, the operator manages a default user named `elastic` with the `superuser` role. Its password is stored in a `Secret` named `<name>-elastic-user`.

[source,sh]
----
> kubectl get secret hulk-elastic-user -o go-template='{{.data.elastic | base64decode }}'
42xyz42citsale42xyz42
----

[float]
[id="{p}-services"]
=== Services

You can access Elasticsearch and Kibana by using native Kubernetes services that are not reachable from the public Internet by default.

[float]
[id="{p}-kubernetes-service"]
==== Managing Kubernetes services

For each resource, `Elasticsearch` or `Kibana`, the operator manages a Kubernetes service named `<name>-[es|kb]-http`, which is of type `ClusterIP` by default. `ClusterIP` exposes the service on a cluster-internal IP and makes the service only reachable from the cluster.

[source,sh]
----
> kubectl get svc

NAME                TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE
hulk-es-http        ClusterIP      10.19.252.160   <none>           9200:31320/TCP   1m
hulk-kb-http        ClusterIP      10.19.247.151   <none>           5601:31380/TCP   1m
----

[float]
[id="{p}-allow-public-access"]
==== Allowing public access

You can expose services in link:https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types[different ways] by specifying an `http.service.spec.type` in the `spec` of the resource manifest.
On cloud providers which support external load balancers, you can set the `type` field to `LoadBalancer` to provision a load balancer for the `Service`, and populate the column `EXTERNAL-IP` after a short delay. Depending on the cloud provider, it may incur charges.

[source,yaml]
----
apiVersion: <kind>.k8s.elastic.co/v1alpha1
kind: <Kind>
metadata:
  name: hulk
spec:
  version: 7.2.0
  http:
    service:
      spec:
        type: LoadBalancer
----

[source,sh]
----
> kubectl get svc

NAME                TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE
hulk-es-http        LoadBalancer   10.19.252.160   35.198.131.115   9200:31320/TCP   1m
hulk-kb-http        LoadBalancer   10.19.247.151   35.242.197.228   5601:31380/TCP   1m
----


[float]
[id="{p}-tls-certificates"]
=== TLS Certificates

This section only covers TLS certificates for the HTTP layer. Those for the transport layer used for internal communication between nodes in a cluster are managed by ECK and are not configurable.

[float]
[id="{p}-default-self-signed-certificate"]
==== Default self-signed certificate

By default, the operator manages a self-signed certificate with a custom CA for Elasticsearch and Kibana.
The CA, the certificate and the private key are each stored in a `Secret`.

[source,sh]
----
> kubectl get secret | grep es-http
hulk-es-http-ca-internal         Opaque                                2      28m
hulk-es-http-certs-internal      Opaque                                2      28m
hulk-es-http-certs-public        Opaque                                1      28m
----

The public certificate is stored in a secret named `<name>-[es|kb]-http-certs-public`.

[source,sh]
----
> kubectl get secret hulk-es-http-certs-public -o go-template='{{index .data "tls.crt" | base64decode }}'
-----BEGIN CERTIFICATE-----
MIIDQDCCAiigAwIBAgIQHC4O/RWX15a3/P3upsm3djANBgkqhkiG9w0BAQsFADA6
...
QLYL4zLEby3vRxq65+xofVBJAaM=
-----END CERTIFICATE-----
----

[float]
[id="{p}-static-ip-custom-domain"]
===== Reserving static IP and custom domain

To use a custom domain name with the self-signed certificate, you can reserve a static IP and/or use an Ingress instead of a `LoadBalancer` `Service`. Whatever you use, your DNS must be added to the certificate SAN in the `spec.http.tls.selfSignedCertificate.subjectAltNames` section of your Elastic resource manifest.

[source,yaml]
----
spec:
  http:
    service:
      spec:
        type: LoadBalancer
    tls:
      selfSignedCertificate:
        subjectAltNames:
        - ip: 160.46.176.15
        - dns: hulk.example.com
----

[float]
[id="{p}-setting-up-your-own-certificate"]
==== Setting up your own certificate

You can bring your own certificate to configure TLS to ensure that communication between HTTP clients and the cluster is encrypted.

Create a Kubernetes secret with:
. tls.crt: the certificate (or a chain).
. tls.key: the private key to the first certificate in the certificate chain.

[source,sh]
----
kubectl create secret tls my-cert --cert tls.crt --key tls.key
----

Then you just have to reference the secret name in the `http.tls.certificate` section of the resource manifest.

[source,yaml]
----
spec:
  http:
    tls:
      certificate:
        secretName: my-cert
----

[float]
[id="{p}-request-elasticsearch-endpoint"]
=== Requesting the Elasticsearch endpoint

You can request the Elasticsearch endpoint within or outside the Kubernetes cluster.

*Within the Kubernetes cluster*

. Retrieve the CA certificate.
. Retrieve the password of the `elastic` user.

[source,sh]
----
NAME=hulk

kubectl get secret "$NAME-ca" -o go-template='{{index .data "ca.pem" | base64decode }}' > ca.pem
PW=$(kubectl get secret "$NAME-elastic-user" -o go-template='{{.data.elastic | base64decode }}')

curl --cacert ca.pem -u elastic:$PW https://$NAME-es:9200/
----

*Outside the Kubernetes cluster*

. Retrieve the CA certificate.
. Retrieve the password of the `elastic` user.
. Retrieve the IP of the `LoadBalancer` `Service`.

[source,sh]
----
NAME=hulk

kubectl get secret "$NAME-ca" -o go-template='{{index .data "ca.pem" | base64decode }}' > ca.pem
IP=$(kubectl get svc "$NAME-es" -o jsonpath='{.status.loadBalancer.ingress[].ip}')
PW=$(kubectl get secret "$NAME-elastic-user" -o go-template='{{.data.elastic | base64decode }}')

curl --cacert ca.pem -u elastic:$PW https://$IP:9200/
----

Now you should get this message:

[source,sh]
----
curl: (51) SSL: no alternative certificate subject name matches target host name '35.198.131.115'
----

Add the external IP of the service to the SANs of the certificate in the same Elasticsearch resource YAML manifest used for creating the cluster and apply it again using `kubectl`.

[source,yaml]
----
spec:
  http:
    service:
      spec:
        type: LoadBalancer
    tls:
      selfSignedCertificate:
        subjectAltNames:
        - ip: 35.198.131.115
----

You can now reach Elasticsearch:

[source,sh]
----
> curl --cacert ca.pem -u elastic:$PASSWORD https://$IP:9200/
{
  "name" : "hulk-es-4qk62zd928",
  "cluster_name" : "hulk",
  "cluster_uuid" : "q6itjqFqRqW576FXF0uohg",
  "version" : {
    "number" : "7.2.0",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "508c38a",
    "build_date" : "2019-06-20T15:54:18.811730Z",
    "build_snapshot" : false,
    "lucene_version" : "8.0.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
----
